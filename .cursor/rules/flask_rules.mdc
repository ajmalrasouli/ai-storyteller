---
description: 
globs: 
alwaysApply: false
---
 # Flask and SQLAlchemy guidelines

## Flask Application Structure

### Project Structure
- Use a modular application structure:
  ```
  /app.py              # Main application entry point
  /models/             # Database models
  /routes/             # API routes 
  /services/           # Business logic
  /static/             # Static files
  /templates/          # Templates (if using server-side rendering)
  ```

### Application Configuration
- Use environment variables for configuration
- Load them with python-dotenv or Flask's built-in config
- Example:
  ```python
  from flask import Flask
  from dotenv import load_dotenv
  import os

  load_dotenv()  # Load environment variables from .env

  app = Flask(__name__)
  app.config['SECRET_KEY'] = os.getenv('SECRET_KEY')
  app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL')
  ```

## SQLAlchemy Models

### Model Definition
- Define models with clear types and relationships
- Include helpful methods on models
- Example:
  ```python
  from flask_sqlalchemy import SQLAlchemy
  from werkzeug.security import generate_password_hash, check_password_hash
  from datetime import datetime

  db = SQLAlchemy()

  class User(db.Model):
      id = db.Column(db.Integer, primary_key=True)
      email = db.Column(db.String(120), unique=True, nullable=False)
      password_hash = db.Column(db.String(128), nullable=False)
      stories = db.relationship('Story', backref='author', lazy=True)
      
      def set_password(self, password):
          self.password_hash = generate_password_hash(password)
          
      def check_password(self, password):
          return check_password_hash(self.password_hash, password)
  ```

### Relationships
- Use appropriate relationship types:
  - `db.relationship` for one-to-many
  - `db.Table` for many-to-many
- Always specify `backref` or `back_populates` for bidirectional relationships

## Flask Routes

### Route Organization
- Group related routes in blueprints
- Example:
  ```python
  from flask import Blueprint, request, jsonify

  auth_bp = Blueprint('auth', __name__, url_prefix='/auth')

  @auth_bp.route('/register', methods=['POST'])
  def register():
      data = request.get_json()
      # Registration logic here
      return jsonify({"message": "User registered successfully"}), 201
  ```

### Error Handling
- Use appropriate HTTP status codes
- Return consistent error response format:
  ```python
  @app.errorhandler(404)
  def not_found(error):
      return jsonify({"message": "Resource not found"}), 404
      
  @app.errorhandler(400)
  def bad_request(error):
      return jsonify({"message": str(error)}), 400
  ```

## API Design

### RESTful Endpoints
- Use RESTful principles for API design:
  - GET /resources - List resources
  - POST /resources - Create a resource
  - GET /resources/:id - Get a specific resource
  - PUT /resources/:id - Update a resource
  - DELETE /resources/:id - Delete a resource

### Request Validation
- Validate request data before processing:
  ```python
  @app.route('/stories', methods=['POST'])
  def create_story():
      data = request.get_json()
      
      # Validate required fields
      if not data:
          return jsonify({"message": "No data provided"}), 400
          
      if 'theme' not in data:
          return jsonify({"message": "Missing required field: theme"}), 400
          
      # Process valid data
      # ...
  ```

## Authentication

### JWT Authentication
- Use Flask-JWT-Extended for JWT authentication
- Example:
  ```python
  from flask_jwt_extended import JWTManager, create_access_token, jwt_required, get_jwt_identity

  jwt = JWTManager(app)

  @app.route('/login', methods=['POST'])
  def login():
      data = request.get_json()
      user = User.query.filter_by(email=data['email']).first()
      
      if user and user.check_password(data['password']):
          access_token = create_access_token(identity=user.id)
          return jsonify({"token": access_token}), 200
      
      return jsonify({"message": "Invalid credentials"}), 401

  @app.route('/protected', methods=['GET'])
  @jwt_required()
  def protected():
      current_user_id = get_jwt_identity()
      # Use current_user_id to get user data
      return jsonify({"message": "This is a protected endpoint"})
  ```

## CORS Configuration

### CORS Setup
- Use Flask-CORS for handling Cross-Origin Resource Sharing:
  ```python
  from flask_cors import CORS

  # Allow all origins (for development)
  CORS(app, resources={r"/*": {"origins": "*"}})

  # Or more restrictive for production
  CORS(app, resources={r"/*": {"origins": "https://yourdomain.com"}})
  ```

## React Integration

### Frontend API Communication
- Create consistent API functions on the frontend:
  ```typescript
  // src/lib/api.ts
  const API_URL = "http://localhost:5000";

  export async function fetchWithAuth(url: string, options: RequestInit = {}) {
    const headers = {
      "Content-Type": "application/json",
      ...options.headers,
    };

    const response = await fetch(`${API_URL}${url}`, {
      ...options,
      headers,
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || "An error occurred");
    }

    return response.json();
  }

  export async function generateStory(theme: string, characters: string[], ageGroup: string) {
    return fetchWithAuth("/stories", {
      method: "POST",
      body: JSON.stringify({ theme, characters, ageGroup }),
    });
  }
  ```

## Database Operations

### Query Best Practices
- Use appropriate query methods:
  - `Model.query.get(id)` - Get by primary key
  - `Model.query.filter_by(attr=value)` - Simple equality filters
  - `Model.query.filter(Model.attr.in_(values))` - More complex filters
  - `Model.query.order_by(Model.attr.desc())` - Ordering
  - `Model.query.limit(count)` - Limit results

### Transaction Management
- Use session transactions for multi-step operations:
  ```python
  try:
      # Create a new story
      story = Story(
          title=title,
          content=story_content,
          theme=data['theme'],
          characters=','.join(data['characters']),
          age_group=data['ageGroup'],
          user_id=1
      )
      db.session.add(story)
      db.session.commit()
      
      return jsonify({
          'id': story.id,
          'title': story.title,
          # other fields...
      }), 201
      
  except Exception as e:
      db.session.rollback()
      return jsonify({'message': str(e)}), 500
  ```

## Azure OpenAI Integration

### Client Setup
```python
from openai import AzureOpenAI

client = AzureOpenAI(
    api_key=os.getenv("AZURE_OPENAI_API_KEY"),
    api_version="2023-05-15",
    azure_endpoint=os.getenv("AZURE_OPENAI_ENDPOINT")
)

# Using the client
response = client.chat.completions.create(
    model="gpt-35-turbo",  # Use your deployment name
    messages=[
        {"role": "system", "content": "You are a creative story writer."},
        {"role": "user", "content": prompt}
    ],
    temperature=0.7,
    max_tokens=800
) 